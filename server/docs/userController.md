Регистрация/вход через Telegram в одном обработчике
Если в теле запроса есть telegramUserId, сначала ищем пользователя по telegramUserId.
Если нашли — считаем это входом: отдаём тот же ответ с токеном (логин), нового пользователя не создаём.
Если не нашли — создаём нового пользователя (регистрация через Telegram).
Пароль только для email
passwordHash считается и сохраняется только если передан req.body.password.
При регистрации только через Telegram пароль не требуется и не хешируется.
Создание пользователя
email и passwordHash добавляются в документ только если они есть в запросе.
Для Telegram, если userName не передан, подставляется tg_<telegramUserId> (как в комментарии в схеме).
Ошибка дубликата
Сообщение при error.code === 11000 обновлено: добавлено упоминание, что дубликат может быть по email, username или Telegram.
В итоге один и тот же endpoint обрабатывает:
Email: email + password (+ по желанию userName и др.) — классическая регистрация.
Telegram: telegramUserId (+ по желанию telegramUsername, telegramPhotoUrl, userName) — первый раз регистрация, последующие разы — вход с выдачей токена.

Если в теле запроса есть telegramUserId → считаем, что это Telegram.
Иначе → считаем, что это email/пароль.

Код обрабатывает два способа входа/регистрации в одном обработчике.

Путь «Telegram» (стр. 10–21)
Если пришёл telegramUserId:
Ищем пользователя по telegramUserId в БД.

Ищем пользователя по telegramUserId в БД.
Если нашли — это не регистрация, а вход:
выдаём JWT по _id пользователя;
возвращаем данные пользователя (без passwordHash) и token;
на этом обработчик заканчивается, нового пользователя не создаём.
Если не нашли — идём дальше и создаём нового пользователя (как в блоке ниже).
